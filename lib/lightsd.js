// Generated by LiveScript 1.2.0
(function(){
  var airport, lock, MicroDB, air, spawn, turnLock, turn, lightsDb, listLights, delLight, delLightByName, addLight, turnLight, scheduleDb, listSchedule, delSchedule, addSchedule, addScheduleLight, scheduleRun, scheduleNext, scheduleTimeout, execSchedule;
  airport = require('airport');
  lock = require('./lock');
  MicroDB = require('nodejs-microdb');
  air = airport('frumar.yori.cc', 9090);
  air(function(remote, conn){
    this.turn = turn;
    this.listLights = listLights;
    this.delLight = delLight;
    this.delLightByName = delLightByName;
    this.addLight = addLight;
    this.turnLight = turnLight;
    this.listSchedule = listSchedule;
    this.delSchedule = delSchedule;
    this.addSchedule = addSchedule;
    this.addScheduleLight = addScheduleLight;
  }).listen('lightsd@0.0.1');
  spawn = require('child_process').spawn;
  turnLock = new lock;
  turn = function(group, num, state){
    if (typeof state === 'boolean') {
      state = state ? 'on' : 'off';
    }
    return turnLock.get(function(){
      var proc;
      console.log("Turning " + state + " " + group + " " + num);
      proc = spawn('./kaku', [group, num, state]);
      proc.stdout.pipe(process.stdout);
      return proc.on('exit', bind$(turnLock, 'free'));
    });
  };
  lightsDb = new MicroDB({
    file: 'lights.db'
  });
  listLights = function(cb){
    return cb(lightsDb.data);
  };
  delLight = bind$(lightsDb, 'del');
  delLightByName = function(name){
    return lightsDb.del(lightsDb.find('name', name));
  };
  addLight = function(name, group, num){
    return lightsDb.add({
      name: name,
      group: group,
      num: num
    });
  };
  turnLight = function(name, state, cb){
    var id, ref$, group, num;
    id = lightsDb.find('name', name);
    if (!id) {
      return typeof cb === 'function' ? cb(false) : void 8;
    } else {
      ref$ = lightsDb.data[id], group = ref$.group, num = ref$.num;
      turn(group, num, state);
      return typeof cb === 'function' ? cb(true) : void 8;
    }
  };
  scheduleDb = new MicroDB({
    file: 'schedule.db'
  });
  listSchedule = function(cb){
    return cb(scheduleDb.data);
  };
  delSchedule = function(){
    scheduleDb.del.apply(this, arguments);
    return execSchedule();
  };
  addSchedule = function(time, group, num, state, desc){
    time = +time;
    desc == null && (desc = '');
    scheduleDb.add({
      time: time,
      group: group,
      num: num,
      state: state,
      desc: desc
    });
    return execSchedule();
  };
  addScheduleLight = function(time, name, state, desc){
    time = +time;
    desc == null && (desc = '');
    scheduleDb.add({
      time: time,
      name: name,
      state: state,
      desc: desc
    });
    return execSchedule();
  };
  scheduleRun = function(s){
    if (s.name != null) {
      return turnLight(s.name, s.state);
    } else {
      return turn(s.group, s.num, s.state);
    }
  };
  scheduleNext = function(){
    var minS, minId, id, ref$, s;
    minS = void 8;
    minId = void 8;
    for (id in ref$ = scheduleDb.data) {
      s = ref$[id];
      if (minS == null || minS.time > s.time) {
        minS = s;
        minId = id;
      }
    }
    return [minId, minS];
  };
  scheduleTimeout = void 8;
  execSchedule = function(){
    var scheduleTimeout, ref$, id, s, now;
    if (scheduleTimeout != null) {
      clearTimeout(scheduleTimeout);
      scheduleTimeout = void 8;
    }
    ref$ = scheduleNext(), id = ref$[0], s = ref$[1];
    if (s == null) {
      console.log("Nothing scheduled");
      return;
    }
    now = Date.now();
    if (s.time < now) {
      console.log("executing something");
      process.nextTick(function(){
        return scheduleRun(s);
      });
      scheduleDb.del(id);
      return execSchedule();
    } else {
      console.log("Scheduling into the future");
      return scheduleTimeout = setTimeout(execSchedule, s.time - now + 100);
    }
  };
  process.on('SIGINT', function(){
    lightsDb.flush();
    scheduleDb.flush();
    process.exit();
  });
  execSchedule();
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
